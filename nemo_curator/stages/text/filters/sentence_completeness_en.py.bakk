import re
from typing import Dict, List, Tuple, Optional
import stanza
import numpy as np
import pandas as pd
import torch


class EnglishCompletenessScorer:
    """
    영어 문장 완결성 점수 계산기
    
    평가 기준:
    1. 문장 시작 (15점) - 접속사, 전치사로 시작하는지 확인
    2. 주어 존재 (10점) - 대명사, 명사 패턴 확인
    3. 서술어 존재 및 품질 (35점) - 동사 형태 확인
    4. 문장 종결 표현 (30점) - 마지막 단어와 구두점 확인
    5. 구조적 완성도 (10점) - 단어 수, 괄호 짝 등
    """
    
    def __init__(self):
        """문법 패턴 및 단어 리스트 초기화"""
        self.nlp_pipeline = None
        self.torch_load_patched = False
        
        # PyTorch weights_only issue fix for Stanza compatibility
        if hasattr(torch, 'serialization') and not self.torch_load_patched:
            try:
                original_load = torch.load
                def patched_load(*args, **kwargs):
                    kwargs['weights_only'] = False
                    return original_load(*args, **kwargs)
                torch.load = patched_load
                self.torch_load_patched = True
            except:
                pass

    def _get_nlp_pipeline(self):
        if self.nlp_pipeline is None:
            try:
                self.nlp_pipeline = stanza.Pipeline('en', processors='tokenize,pos,lemma,depparse', verbose=False, use_gpu=False)
            except Exception:
                stanza.download('en', verbose=False)
                self.nlp_pipeline = stanza.Pipeline('en', processors='tokenize,pos,lemma,depparse', verbose=False, use_gpu=False)
        return self.nlp_pipeline    
    
    def calculate_score(self, text: str) -> int:
        """
        영어 문장의 완결성 점수를 계산 (0-100점)
        
        Args:
            text: 검사할 영어 문장
            
        Returns:
            int: 완결성 점수 (0-100)
        """
        text = text.strip()
        if not text:
            return 0
        
        nlp = self._get_nlp_pipeline()
        try:
            st_doc = nlp(text)
        except Exception:
            # Stanza 처리 중 오류 발생 시 기본 점수 (낮게)
            return 20 

        if not st_doc.sentences:
            return 0
        
        sent = st_doc.sentences[0] # 첫 번째 문장만 분석
        
        total_score = 0
        
        # ===== 1. 문장 시작 검사 (15점) =====
        total_score += self._check_sentence_start(sent)
        
        # ===== 2. 주어 존재 검사 (10점) =====
        total_score += self._check_subject(sent)
        
        # ===== 3. 서술어 존재 및 품질 검사 (35점) =====
        total_score += self._check_predicate(sent)
        
        # ===== 4. 문장 종결 표현 검사 (30점) =====
        total_score += self._check_sentence_ending(sent, text)
        
        # ===== 5. 구조적 완성도 검사 (10점) =====
        total_score += self._check_structure(sent, text)
        
        # ===== 6. 종속절 처리 =====
        total_score = self._apply_clause_penalties(sent, total_score, text)
        
        # ===== 7. 추가 패널티 적용 =====
        # 종결어미(완전한 동사 형태) 없으면 점수 제한
        has_complete_verb = self._has_complete_verb_form(sent)
        has_proper_ending = text.rstrip()[-1] in {'.', '?', '!'} if text.rstrip() else False
        
        if not has_complete_verb and not has_proper_ending:
            total_score = min(total_score, 55)
        
        return max(0, min(100, total_score))
    
    def _check_sentence_start(self, sent: stanza.models.common.doc.Sentence) -> int:
        """문장 시작 검사 (Stanza 활용)"""
        if not sent.words:
            return 0
        
        first_word = sent.words[0]
        first_token_text = first_word.text.lower()
        first_pos = first_word.upos
        
        # 등위접속사 (CCONJ)로 시작
        if first_pos == 'CCONJ':
            return 0
        
        # 분사 (VERB with VBG or VBN)로 시작
        # -ing 형태 (VBG)
        if first_pos == 'VERB' and first_word.xpos == 'VBG':
            return 3
        # 과거분사 (VBN)
        if first_pos == 'VERB' and first_word.xpos == 'VBN':
            return 3
        
        # 전치사 (ADP)로 시작
        if first_pos == 'ADP':
            # After, Before 등은 SCONJ로도 쓰일 수 있으나 여기서는 ADP로 판단
            return 3
        
        # 구두점으로 시작
        if first_pos == 'PUNCT':
            return 0
        
        # 종속접속사 (SCONJ)로 시작
        if first_pos == 'SCONJ':
            return 5
        
        # 대명사 (PRON), 한정사 (DET: 관사 포함)로 시작
        if first_pos in {'PRON', 'DET'}:
            return 15
        
        # 명사 (NOUN, PROPN)로 시작
        if first_pos in {'NOUN', 'PROPN'}:
            return 15
        
        # 숫자 (NUM)로 시작
        if first_pos == 'NUM' or first_token_text.isdigit():
            return 3
        
        return 10
    
    def _check_subject(self, sent: stanza.models.common.doc.Sentence) -> int:
        """주어 존재 검사 (Stanza 활용)"""
        has_nsubj = False
        has_csubj = False
        
        for word in sent.words:
            if word.deprel == 'nsubj': # 명사 주어
                has_nsubj = True
            elif word.deprel == 'csubj': # 절 주어
                has_csubj = True
        
        if has_nsubj or has_csubj:
            return 10
        
        # 주어가 없지만, 명령문일 가능성 (ROOT 동사로 시작)
        # Stanza의 의존성 파싱 결과에서 ROOT가 동사이고, nsubj가 없으면 명령문일 확률 높음
        if sent.words and sent.words[0].upos == 'VERB' and sent.words[0].deprel == 'root':
            # 주어 대명사 (you 등)가 생략된 경우 (명령문)
            return 8 # 주어 점수 일부 부여
        
        return 0
    
    def _check_predicate(self, sent: stanza.models.common.doc.Sentence) -> int:
        """서술어 존재 및 품질 검사 (Stanza 활용)"""
        has_main_verb = False
        has_auxiliary = False
        
        for word in sent.words:
            if word.deprel == 'root': # 문장의 핵심 동사/서술어
                if word.upos == 'VERB':
                    has_main_verb = True
                elif word.upos == 'AUX': # be 동사 등도 root가 될 수 있음
                    has_main_verb = True
            
            if word.upos == 'AUX':
                has_auxiliary = True
        
        # 주된 동사(서술어)가 있는 경우
        if has_main_verb:
            return 35
        
        # 조동사만 있고 본동사가 없는 경우 (불완전)
        if has_auxiliary and not has_main_verb:
            return 10 # "It is" 같은 경우
        
        # 동사가 전혀 없는 경우 (명사구, 전치사구 등)
        return 0
    
    def _check_sentence_ending(self, sent: stanza.models.common.doc.Sentence, text: str) -> int:
        """문장 종결 표현 검사 (Stanza 활용)"""
        if not sent.words:
            return 0
        
        last_word = sent.words[-1]
        last_token_text = last_word.text.lower()
        last_pos = last_word.upos
        
        # 마지막 문자 확인 (구두점)
        last_char = text.rstrip()[-1] if text.rstrip() else ''
        has_end_punct = last_char in {'.', '?', '!'}
        is_question = last_char == '?'
        is_exclamation = last_char == '!'
        
        # === 명백히 불완전한 종결 패턴 ===
        
        # 1. 전치사 (ADP)로 끝남
        if last_pos == 'ADP':
            return -30
        
        # 2. 등위접속사 (CCONJ)로 끝남
        if last_pos == 'CCONJ':
            return -30
        
        # 3. 종속접속사 (SCONJ)로 끝남
        if last_pos == 'SCONJ':
            return -25
        
        # 4. 'to' (PART)로 끝남 (부정사 표지)
        if last_pos == 'PART' and last_token_text == 'to':
            return -25
        
        # 4-1. 'that' (SCONJ or DET)으로 끝남 (불완전한 종결)
        if last_token_text == 'that' and (last_pos == 'SCONJ' or last_pos == 'DET'):
            return -25
        
        # 4-2. 관계대명사 (PRON)로 끝남
        if last_pos == 'PRON' and last_token_text in {'which', 'who', 'whom', 'whose'}:
            return -25
        
        # 5. 한정사 (DET: 관사 포함)로 끝남
        if last_pos == 'DET':
            return -20
        
        # 6. 'very', 'too', 'quite', 'rather', 'fairly' (ADV)
        if last_pos == 'ADV' and last_token_text in {'very', 'too', 'quite', 'rather', 'fairly'}:
            return -25
        
        # 7. -ing 형태로 끝남 (VERB, VBG)
        if last_pos == 'VERB' and last_word.xpos == 'VBG' and not has_end_punct:
            return -20
        
        # === 완전한 종결 패턴 ===
        
        # 의문문 (물음표로 끝나고 WH-word로 시작)
        if is_question and sent.words[0].upos == 'PRON' and sent.words[0].text.lower() in {'what', 'where', 'when', 'why', 'who', 'whom', 'which', 'how'}:
            return 30
        
        # 감탄문 (느낌표로 끝나고 WH-word로 시작)
        if is_exclamation and sent.words[0].upos == 'PRON' and sent.words[0].text.lower() in {'what', 'how'}:
            return 30
        
        # 완전한 동사 형태 확인 (주동사 또는 조동사)
        has_complete_verb = False
        for word in sent.words:
            if word.deprel == 'root' and (word.upos == 'VERB' or word.upos == 'AUX'):
                has_complete_verb = True
                break
        
        # 1. 구두점 + 완전한 동사
        if has_end_punct and has_complete_verb:
            return 30
        
        # 2. 구두점만 (형용사/명사로 끝나는 경우)
        if has_end_punct:
            if is_exclamation:
                return 25
            return 20
        
        # 3. 완전한 동사만 (구두점 없음)
        if has_complete_verb:
            return 22
        
        # 4. 명사로 끝남
        if last_pos in {'NOUN', 'PROPN'}:
            if has_end_punct:
                return 15
            else:
                return 8
        
        return 10
    
    def _check_structure(self, sent: stanza.models.common.doc.Sentence, text: str) -> int:
        """구조적 완성도 검사 (Stanza 활용)"""
        token_count = len(sent.words)
        
        score = 0
        
        # 토큰 수에 따른 점수
        if token_count >= 5:
            score = 10
        elif token_count >= 3:
            score = 7
        elif token_count >= 2:
            score = 4
        else:
            score = 2
        
        # 괄호 짝 검사
        if not self._check_bracket_balance(text):
            return 0
        
        # 과도한 구두점 검사 (Stanza POS 활용)
        punct_count = sum(1 for word in sent.words if word.upos == 'PUNCT')
        non_punct_count = token_count - punct_count
        
        if non_punct_count > 0 and punct_count > non_punct_count * 0.5:
            score = max(0, score - 3)
        
        return score
    
    def _check_bracket_balance(self, text: str) -> bool:
        """괄호 짝 검사"""
        stack = []
        pairs = {'(': ')', '[': ']', '{': '}'}
        
        for char in text:
            if char in pairs:
                stack.append(char)
            elif char in pairs.values():
                if not stack:
                    return False
                open_bracket = stack.pop()
                if pairs[open_bracket] != char:
                    return False
        
        return len(stack) == 0
    
    def _apply_clause_penalties(self, sent: stanza.models.common.doc.Sentence, score: int, text: str) -> int:
        """종속절 및 불완전 구문 패널티 적용 (Stanza 활용)"""
        if not sent.words:
            return score
        
        first_word = sent.words[0]
        first_token_text = first_word.text.lower()
        
        # 주동사(ROOT 동사/조동사) 존재 여부 확인
        has_main_verb = any(word.deprel == 'root' and (word.upos == 'VERB' or word.upos == 'AUX') for word in sent.words)
        
        # 쉼표 존재 여부 확인
        has_comma = any(word.text == ',' for word in sent.words)
        
        # 1. 분사로 시작하는 경우 (분사구문) - 주절 없으면 강력한 감점
        if (first_word.upos == 'VERB' and (first_word.xpos == 'VBG' or first_word.xpos == 'VBN')
            and not has_main_verb):
            if not has_comma: # 쉼표 없으면 주절이 아닐 가능성 높음
                score = min(score, 45)  
        
        # 2. 관계대명사/관계부사로 시작하는 경우 (관계절만 있는 불완전 문장)
        rel_pronouns = {'who', 'whom', 'whose', 'which', 'that'}
        rel_adverbs = {'where', 'when', 'why'}
        if first_token_text in rel_pronouns or first_token_text in rel_adverbs:
            # 주동사가 없으면 관계절만 있는 것으로 판단
            if not has_main_verb:
                score = min(score, 45)
        
        # 3. 종속접속사 (SCONJ)로 시작하는 경우 (종속절만 있는 불완전 문장)
        if first_word.upos == 'SCONJ':
            if not has_main_verb and not has_comma: # 쉼표도 없고 주동사도 없으면 불완전
                score = min(score, 50)
        
        # 4. 전치사구로 시작하는 경우
        if first_word.upos == 'ADP':
            # 주동사가 없으면 전치사구만 있는 불완전 문장일 가능성
            if not has_main_verb and not has_comma:
                score = min(score, 45)
        
        # 5. "To + 동사" 형태 (부정사구만)
        if first_token_text == 'to' and len(sent.words) > 1 and sent.words[1].upos == 'VERB':
            if not has_main_verb:
                score = min(score, 48)
        
        # 6. 명사구만 있는 패턴 감지 (주동사 없고, 마침표 없는 경우)
        has_final_punct = text.strip()[-1] in {'.', '?', '!'} if text.strip() else False
        if not has_main_verb and not has_final_punct:
            # 문장 전체가 동사 없이 명사/형용사/전치사 등으로만 이루어진 경우
            all_nominal_or_adj = all(word.upos in {'NOUN', 'PROPN', 'ADJ', 'DET', 'ADP'} for word in sent.words)
            if all_nominal_or_adj:
                score = min(score, 30) # 매우 낮은 점수
            else:
                score = min(score, 55) # 동사 없는 문장은 감점
        
        return score
    
    def _has_complete_verb_form(self, sent: stanza.models.common.doc.Sentence) -> bool:
        """완전한 동사 형태(주동사)가 있는지 확인 (Stanza 활용)"""
        for word in sent.words:
            if word.deprel == 'root' and (word.upos == 'VERB' or word.upos == 'AUX'):
                return True
        return False
    
    def analyze_with_details(self, text: str) -> Dict:
        """상세 분석 결과 반환 (Stanza 활용)"""
        text = text.strip()
        if not text:
            return {
                'sentence': text,
                'total_score': 0,
                'start_score': 0,
                'subject_score': 0,
                'predicate_score': 0,
                'ending_score': 0,
                'structure_score': 0,
                'token_count': 0,
                'has_end_punctuation': False,
                'starts_with_subordinator': False,
                'ends_with_preposition': False,
            }

        nlp = self._get_nlp_pipeline()
        try:
            st_doc = nlp(text)
        except Exception:
            # Stanza 처리 중 오류 발생 시 기본 점수 (낮게)
            return {
                'sentence': text,
                'total_score': 20,
                'start_score': 0,
                'subject_score': 0,
                'predicate_score': 0,
                'ending_score': 0,
                'structure_score': 0,
                'token_count': 0,
                'has_end_punctuation': False,
                'starts_with_subordinator': False,
                'ends_with_preposition': False,
            }

        if not st_doc.sentences:
            return {
                'sentence': text,
                'total_score': 0,
                'start_score': 0,
                'subject_score': 0,
                'predicate_score': 0,
                'ending_score': 0,
                'structure_score': 0,
                'token_count': 0,
                'has_end_punctuation': False,
                'starts_with_subordinator': False,
                'ends_with_preposition': False,
            }
        
        sent = st_doc.sentences[0]
        
        # 각 항목별 점수 계산
        start_score = self._check_sentence_start(sent)
        subject_score = self._check_subject(sent)
        predicate_score = self._check_predicate(sent)
        ending_score = self._check_sentence_ending(sent, text)
        structure_score = self._check_structure(sent, text)
        
        total_score = start_score + subject_score + predicate_score + ending_score + structure_score
        total_score = self._apply_clause_penalties(sent, total_score, text)
        total_score = max(0, min(100, total_score))
        
        # 추가 상세 정보
        has_end_punct = text.rstrip()[-1] in {'.', '?', '!'} if text.rstrip() else False
        starts_with_subordinator = sent.words[0].upos == 'SCONJ' if sent.words else False
        ends_with_preposition = sent.words[-1].upos == 'ADP' if sent.words else False

        return {
            'sentence': text,
            'total_score': total_score,
            'start_score': start_score,
            'subject_score': subject_score,
            'predicate_score': predicate_score,
            'ending_score': ending_score,
            'structure_score': structure_score,
            'token_count': len(sent.words),
            'has_end_punctuation': has_end_punct,
            'starts_with_subordinator': starts_with_subordinator,
            'ends_with_preposition': ends_with_preposition,
        }